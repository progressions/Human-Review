#!/usr/bin/env php
<?php



ini_set('open_basedir', "");
ini_set('error_log', dirname(__FILE__) . '/error.log');
ini_set('display_errors', 'On');
ini_set('error_reporting', E_ERROR);

function verify($cond, $msg)
{
    if($cond)
        return;
    throw new Exception($msg);
}

function stripDocComment($str)
{
    $lines = explode("\n", $str);
    $lines = array_slice($lines, 1, -1);
    //trim leading spaces from first line
    //and trim equal space from subsequent lines
    $leading_spaces= strlen($lines[0]);
    $lines[0] = ltrim($lines[0]);
    $leading_spaces -= strlen($lines[0]);
    $new = array($lines[0]);
    foreach(array_slice($lines, 1) as $line){
        $new[] = substr($line, $leading_spaces);
    }
    return implode("\n", $new);
}


///Shared impl between ymdt and om_admin
class CLI
{
    protected $ws;

    const OPTS___CONSTRUCT = 'h:ku:p:x:dv';
    public function __construct($hostname = null, $lamessl = false, 
                                $username = null, $password = null, $proxyOpts = null,
                                $nocookies = null, $verbose = false, $cookieFname = '.cookie',
                                $authType = 'Yahoo!')
    {
        if (version_compare(PHP_VERSION, '5.2.0') < 0) {
            echo "PHP version must be at least 5.2.\n".
                "You are running PHP version " . PHP_VERSION . ".\n".
                "Please visit http://php.net/ to upgrade your PHP installation.\n\n";
    
            exit(-1);
        }

        if(!extension_loaded('openssl')){
            echo "PHP openssl module required.\n";
            exit(-1);
        }

        if(!extension_loaded('curl')){
            echo "PHP curl module required.\n";
            exit(-1);
        }

        $curlVersion = curl_version();

        if(!$curlVersion['features'] & CURL_VERSION_SSL){
            echo "PHP curl module must be built with SSL support.\n";
            exit(-1);
        }

        if (!$hostname) {
            $ymdt_host = getenv('YMDT_HOST');
            $hostname = $ymdt_host ? $ymdt_host : 'developer.mail.yahoo.com';
        }

        $lamessl_hosts = array( 'om0001.mail.mud.yahoo.com',
                                'om0002.mail.mud.yahoo.com',
                                'om0101.mail.mud.yahoo.com',
                                'om0102.mail.mud.yahoo.com'
                                );
        $lamessl = $lamessl || in_array($hostname, $lamessl_hosts);

        $cookieFname = Login::getHomeDir() . '/' . $cookieFname;

        if($nocookies){
            verify( !file_exists($cookieFname) || unlink($cookieFname), 
                    "Couldn't delete " . $cookieFname . '.');
            $cookieFname = null;
        }
        else{
            //            FileSys::verifyPath(Login::getHomeDir());
        }

        $proxy = null;
        $proxyType = null;
        if($proxyOpts){
            $proxyOpts = explode(',', $proxyOpts);
            $proxyType = $proxyOpts[0];
            verify(in_array($proxyType, array('http', 'socks5', '5')), 
                   'proxy protocol must be either http or socks5.');
            if(count($proxyOpts) > 1)
                $proxy = $proxyOpts[1];
            if($proxyType == 'http'){
                $proxyType = CURLPROXY_HTTP;
                $proxy = $proxy ? $proxy : getenv('http_proxy');
                verify($proxy, "-xhttp requires ',host:port' or http_proxy " .
                       "env var to be set.");
            }
            else{
                $proxyType = CURLPROXY_SOCKS5;
                $proxy = $proxy ? $proxy : getenv('YMDT_PROXY_SOCKS5');
                verify($proxy, "-xsocks5 requires ',host:port' or YMDT_PROXY_SOCKS5 " .
                       "env var to be set.");
            }
        }

        if($hostname == 'localhost')
            $hostname = php_uname('n');

        $this->verbose = $verbose;
        $this->ws = new WebServiceClient($hostname, $cookieFname, $lamessl, 
                                         $username, $password, $proxyType, $proxy,
                                         $verbose, $authType);
    }

    //    const OPTS_HELP = 'v';
    /**
       usage: help <command>

       Give help for a particular command.

       For general usage, run without any arguments.

       Options:
           -v
           verbose (show options for overriding hostname, proxies, etc.)

    */
    function help($command)
    {
        $ro = new ReflectionObject($this);
        $method = $ro->getMethod('isLegalCmd');
        if(!$method->invoke(null, $command)){
            echo 'Command ' . $command . ' unknown.' . "\n\n";
            return;
        }

        global $CLI_COMMON_OPTIONS;
        $method = new ReflectionMethod($this, $command);
        echo stripDocComment($method->getDocComment());
        if($this->verbose)
            echo "\n\n$CLI_COMMON_OPTIONS\n";
        else
            echo "\n\n[Global options suppressed, help -v to show them.]\n\n";
    }

}

$CLI_COMMON_OPTIONS = <<<EOT
Global Options:

        -h<host>
            Override default Yahoo! Mail developer hostname.
            (Default is YMDT_HOST environment variable or 'developer.mail.yahoo.com')

        -u<user>
            Specify user ID.  If this option is omitted, the user ID is either
            figured from cookies or by prompting the user.

            After authentication, a token is normally cached in a cookie file in your
            home directory.  It does not contain your password.  This time-sensitive
            token will be reused on subsequent invocations to avoid logging on.  Use
            the -d flag to avoid writing that file and force login on every invocation.

        -d
            Don't save auth token to file.

        -p<password>
            You're better off not using this option and letting the program offer you a
            masked prompt for password entry.

        -k
            Disables SSL host verification, use if the host you're connecting to is
            using self-signed SSL certs.

        -x<http|socks5[,host:port]>
            Use an http or socks5 proxy.  If ,host:port isn't specified, will use 
            env var http_proxy for http or env var YMDT_PROXY_SOCKS for socks5.

        -v 
            Verbose.

EOT;







//Dispatch command line onto a class instance.
//Command-line of form:
//<exe> <command> [switches and args]
//
class CmdLineDispatcher
{
    const DEBUG_MODE = false;

    function __construct($className)
    {
        $this->className = $className;
    }

    private function showUsage()
    {
        $cls = new ReflectionClass($this->className);
        $usage = stripDocComment($cls->getDocComment());
        echo $usage . "\n\n";
        exit(-1);
    }

    function dispatch()
    {
        try{
            $this->dispatchInternal();
        }
        catch(Exception $e){
            echo $e->getMessage() . "\n";
            if(self::DEBUG_MODE)
                throw $e;
        }
    }
    
    private function dispatchInternal()
    {
        if(count($GLOBALS['argv']) < 2){
            echo "\nFirst argument must be a command\n\n";
            $this->showUsage();
        }

        $cmd = $GLOBALS['argv'][1];
        $method = new ReflectionMethod($this->className, 'isLegalCmd');
        if(!$method->invoke(null, $cmd)){
            echo "\nFirst argument must be a command.\n"
                ."'$cmd' is not a legal command.\n\n";
            $this->showUsage();
        }

        //get constructor optstring, opt params
        //get command optstring, opt params, required params

        list($ctor, $ctorOptString, $ctorRequiredParamCount) = 
            $this->getMethodMetadata('__construct');

        list($method, $cmdOptString, $cmdRequiredParamCount) = 
            $this->getMethodMetadata($cmd);

        $ctorOptChars = str_replace(':', '', $ctorOptString);
        verify(!strpbrk($ctorOptChars, $cmdOptString),
               "Internal error: $cmd optstring clashes with common optstring.");

        //array of option char ==> value
        $options = $this->getopts_and_reindex($cmdOptString . $ctorOptString);

        //Invoke constructor with cookieFname, <optional parameters. . .>
        //All optional take defaults unless overridden at command line.
        global $HOMEDIR;

        $paramVals = $this->getMethodOptionalParamVals($ctor,$ctorOptString, 
                                                       $options);
        //create it
        //   echo "params: " . print_r($paramVals, true) . "\n\n";
        $class = new ReflectionClass($this->className);
        $instance = $class->newInstanceArgs($paramVals);

        $argCount = count($GLOBALS['argv']) - 2;
        if($argCount < $cmdRequiredParamCount){
            echo "\n$cmd expected at least $cmdRequiredParamCount argument(s), " . 
                "got $argCount.\n\n";
            $instance->help($cmd, array_key_exists('v', $options));
            exit(-1);
        }

        $paramVals = array_slice($GLOBALS['argv'], 2, $cmdRequiredParamCount); 
        $paramVals = array_merge($paramVals, 
                                 $this->getMethodOptionalParamVals($method, 
                                                                   $cmdOptString, 
                                                                   $options));
        // echo    print_r($paramVals, true);
        //invoke the command
        echo "$cmd:\n";
        //       implode(' ', array_slice($paramVals, 0, $cmdRequiredParamCount)). "\n\n";

        $method->invokeArgs($instance, $paramVals);
    }

    //Given an options string as taken by getopt(), return options array and reindex
    //global argv to omit the options.
    function getopts_and_reindex($opts)
    {
        try {
            list($options, $rest) = Console_Getopt::getopt($GLOBALS['argv'], $opts);
        }
        catch(Exception $e){
            global $DEBUG_MODE;
            echo $e->getMessage() . "\n";
            if($DEBUG_MODE)
                throw $e;
            $this->showUsage();
        }

        $GLOBALS['argv'] = array_merge(array('ymdt'), $rest);
        //    echo "OPTS: $opts\n";
        //echo "OPTIONS:\n" . print_r($options, true);
        //echo "ARGV:\n" . print_r($GLOBALS['argv'], true);
        return $options;
    }

    private function getMethodMetadata($methodName)
    {
        $class = new ReflectionClass($this->className);
        $optString = $class->getConstant(strtoupper('OPTS_' . $methodName));

        $method = new ReflectionMethod($this->className, $methodName);
        $params = $method->getParameters();
        $optionalParamNames = array();
        $requiredParamCount = $method->getNumberOfRequiredParameters();
        foreach($params as $ndx=>$p){
            if($ndx < $requiredParamCount)
                continue;
            $optionalParamNames[] = $p->getName();
        }

        //Optional parameters come either from -xYYY command-line or just plain argv args
        $optChars = str_replace(':', '', $optString);
        verify(strlen($optChars) <= count($optionalParamNames),
               "Internal error:  $methodName optstring wrong len.");
        return array($method, $optString, $requiredParamCount);
    }

    private function getMethodOptionalParamVals($method, $optString, $options)
    {
        $params = $method->getParameters();
        $requiredParamCount = $method->getNumberOfRequiredParameters();
        $optionalParamCount = $method->getNumberOfParameters() - $requiredParamCount;

        $optChars = str_replace(':', '', $optString);
        $paramVals = array();

        //Switchless as in specified w/o a command-line switch, i.e. for:
        //ymdt destroy myappdir    #myappdir is a switchless optional param
        //ymdt destroy -a myappid  #myappid is a command-line switch optional param
        $switchlessOptionalParamCount = $optionalParamCount - strlen($optChars);

        //Grab the switchless optional params that came from argv, unspecified ones
        //will get default vals. +2 excludes 'ymdt' and command
        $paramVals = array_slice($GLOBALS['argv'], $requiredParamCount + 2, $switchlessOptionalParamCount);
        $defaultSwitchlessOptionalParamCount = $switchlessOptionalParamCount - count($paramVals);
        $defaultSwitchlessOptionalParamCount = max(0, $defaultSwitchlessOptionalParamCount);
        //    echo "sOPC $switchlessOptionalParamCount, dSOPC
        //    $defaultSwitchlessOptionalParamCount rPC $requiredParamCount\n";
        //    echo "paramVals " . print_r($paramVals, true);

        for($i = 0; $i < $defaultSwitchlessOptionalParamCount; $i++){
            $paramNdx = $requiredParamCount + $i;
            $paramVals[] = $params[$paramNdx]->getDefaultValue();
        }

        //Grab the optional params that are specified by a command-line switch
        $switchOptionalParamCount = strlen($optChars);
        for($i = 0; $i < $switchOptionalParamCount; $i++){
            $paramNdx = $requiredParamCount + $defaultSwitchlessOptionalParamCount + $i;
            $optChar = $optChars[$i];
            if(array_key_exists($optChar, $options))
                $paramVals[] = strlen($options[$optChar]) ? $options[$optChar] : true;
            else
                $paramVals[] = $params[$paramNdx]->getDefaultValue();
        }

        return $paramVals;
    }


}




//File-system utility functions.  Mostly for dealing with ymdt local app working
//directories.

class FileSys
{
    const APPID_FNAME = '.appid';

    //just like realpath, but no backslashes, not even on Windows
    static function realpath($path)
    {
        $path = realpath($path);
        return str_replace('\\', '/', $path);
    }

    //verify path falls within open_basedir
    static function verifyPath($path)
    {
        $fullpath = realpath($path);

        verify($fullpath !== false, "Your home dir and app's ".
               "working dir must fall under the open_basedir paths from php.ini.\n");
    }

    //$paths is an array of (possibly relative) paths / patterns.
    //Expand directories to their file paths.
    //Allows globs.
    //All paths will be absolute.
    //Ignores root readme.txt
    static function expandPaths($paths)
    {
        $more_paths = array();
        foreach($paths as $ndx => $path){
            if(!is_dir($path))
                continue;
            unset($paths[$ndx]);
            $expanded = glob(FileSys::realpath($path) . '/*', GLOB_MARK);
            if(!empty($expanded))
                $more_paths = array_merge($more_paths, $expanded);
        }

        if(empty($more_paths))
            return array_map(array('FileSys', 'realpath'), $paths);

        return self::expandPaths(array_merge($paths, $more_paths));
    }

    static function filterMetaFiles($paths, $basepath, $filterScopes)
    {
        $newpaths = array();
        $metas = array($basepath.'/'.self::APPID_FNAME,
                       $basepath.'/readme.txt');
                       
        foreach($paths as $p){
            if(in_array($p, $metas))
                continue;
            //various emacs/vi backup files, dotfiles
            if($p[0] == '.' || $p[0] == '#')
                continue;
            $lastChar = $p[strlen($p)-1];
            if($lastChar == '~' || $lastChar == '#')
                continue; 
            if($filterScopes && strstr($p, 'yhoo_scopes.txt') !== FALSE)
                continue;
            $newpaths[] = $p;
        }

        return $newpaths;
    }

    static function filterNonTextPaths($paths)
    {
        $txt_extensions = array('htm', 'html', 'js', 'css', 'txt');
        $results = array();
        foreach($paths as $p){
            if(in_array(pathinfo($p, PATHINFO_EXTENSION), $txt_extensions))
                $results[] = $p;
        }
        return $results;
    }

    static function layout($appdir)
    {
        global $YMDT_README;

        $subdirs = array($appdir.'/views', $appdir.'/assets');
        foreach($subdirs as $s){
            verify(file_exists($s) || self::mkdir($s), 
                   "Couldn't make subdir $s.");
        }
        
        $readme = $appdir.'/readme.txt';
        verify(file_put_contents($readme, $YMDT_README),
               "Couldn't write $readme");
    }

    static function mkdir($path)
    {
        if(is_dir($path))
            return;
        return mkdir($path, 0755, true);
    }

    static function modTime($path)
    {
        $stat = stat($path);
        return $stat['mtime'];
    }

    static function nameFromConfFile($appdir)
    {
        $confFname = $appdir . '/config.xml';
        $xml = simplexml_load_file($confFname);
        verify(is_a($xml, 'SimpleXMLElement'), 
               "Couldn't read XML conf from $confFname");
        return $xml->name;
    }

    function isAppWorkingDirRoot($path)
    {
        $appid_path = $path . '/' . self::APPID_FNAME;
        if(file_exists($appid_path))
            return true;

        //Normally, there's already a '.appid' in the root dir, and that's a
        //good enough test.  In some cases (i.e. fresh svn sync), there might 
        //not be a .appid yet and we still want to detect by looking for 
        //required files/directories.
        return file_exists("$path/config.xml") && file_exists("$path/views") &&
               file_exists("$path/assets");
    }

    //returns array(appid, basepath, subpath)
    //basepath is absolute path to app root, i.e. the dir that contains .appid
    //subpath is the path (file/dir/pattern) relative to basepath
    //filename is the filename (or terminating glob / null if dir)
    function parsePath($path)
    {
        $newpath = FileSys::realpath($path);
        if(!$newpath){
            $newpath = FileSys::realpath(dirname($path)) . '/' . basename($path);
            //really only support globs in filenames, no higher up the path
            verify($newpath, "unsupported glob in dirname $path ?");
        }
        $path = $newpath;

        //Keep on going up the path until we find the magic .appid file
        $base = $path;
        if(!is_dir($base))
            $base = dirname($base);
        
        while(!self::isAppWorkingDirRoot($base)){
            verify($base != '.' && $base != '/' && $base != '' 
                   && substr($base, 1) != ':\\',
                   "Unable to find app working dir root along $path");

            $base = dirname($base);
        }
        
        $appid_path = $base . '/' . self::APPID_FNAME;
        $appid = file_get_contents($appid_path);
        $subpath = substr($path, strlen($base)+1);

        return array($appid, $base, $subpath);
    }
};



/* vim: set expandtab tabstop=4 shiftwidth=4: */
// +----------------------------------------------------------------------+
// | PHP Version 5                                                        |
// +----------------------------------------------------------------------+
// | Copyright (c) 1997-2004 The PHP Group                                |
// +----------------------------------------------------------------------+
// | This source file is subject to version 3.0 of the PHP license,       |
// | that is bundled with this package in the file LICENSE, and is        |
// | available through the world-wide-web at the following url:           |
// | http://www.php.net/license/3_0.txt.                                  |
// | If you did not receive a copy of the PHP license and are unable to   |
// | obtain it through the world-wide-web, please send a note to          |
// | license@php.net so we can mail you a copy immediately.               |
// +----------------------------------------------------------------------+
// | Author: Andrei Zmievski <andrei@php.net>                             |
// +----------------------------------------------------------------------+
//
// $Id: Getopt.php,v 1.4 2007/06/12 14:58:56 cellog Exp $


/**
 * Command-line options parsing class.
 *
 * @author Andrei Zmievski <andrei@php.net>
 *
 */
class Console_Getopt {
    /**
     * Parses the command-line options.
     *
     * The first parameter to this function should be the list of command-line
     * arguments without the leading reference to the running program.
     *
     * The second parameter is a string of allowed short options. Each of the
     * option letters can be followed by a colon ':' to specify that the option
     * requires an argument, or a double colon '::' to specify that the option
     * takes an optional argument.
     *
     * The third argument is an optional array of allowed long options. The
     * leading '--' should not be included in the option name. Options that
     * require an argument should be followed by '=', and options that take an
     * option argument should be followed by '=='.
     *
     * The return value is an array of two elements: the list of parsed
     * options and the list of non-option command-line arguments. Each entry in
     * the list of parsed options is a pair of elements - the first one
     * specifies the option, and the second one specifies the option argument,
     * if there was one.
     *
     * Long and short options can be mixed.
     *
     * Most of the semantics of this function are based on GNU getopt_long().
     *
     * @param array  $args           an array of command-line arguments
     * @param string $short_options  specifies the list of allowed short options
     * @param array  $long_options   specifies the list of allowed long options
     *
     * @return array two-element array containing the list of parsed options and
     * the non-option arguments
     *
     * @access public
     *
     */
    function getopt2($args, $short_options, $long_options = null)
    {
        return Console_Getopt::doGetopt(2, $args, $short_options, $long_options);
    }

    /**
     * This function expects $args to start with the script name (POSIX-style).
     * Preserved for backwards compatibility.
     * @see getopt2()
     */    
    function getopt($args, $short_options, $long_options = null)
    {
        return Console_Getopt::doGetopt(1, $args, $short_options, $long_options);
    }

    /**
     * The actual implementation of the argument parsing code.
     */
    function doGetopt($version, $args, $short_options, $long_options = null)
    {
        // in case you pass directly readPHPArgv() as the first arg
        //        if (PEAR::isError($args)) {
        //          return $args;
        //        }
        if (empty($args)) {
            return array(array(), array());
        }
        $opts     = array();
        $non_opts = array();

        settype($args, 'array');

        if ($long_options) {
            sort($long_options);
        }

        /*
         * Preserve backwards compatibility with callers that relied on
         * erroneous POSIX fix.
         */
        if ($version < 2) {
            if (isset($args[0]{0}) && $args[0]{0} != '-') {
                array_shift($args);
            }
        }

        reset($args);
        while (list($i, $arg) = each($args)) {

            /* The special element '--' means explicit end of
               options. Treat the rest of the arguments as non-options
               and end the loop. */
            if ($arg == '--') {
                $non_opts = array_merge($non_opts, array_slice($args, $i + 1));
                break;
            }

            if ($arg{0} != '-' || (strlen($arg) > 1 && $arg{1} == '-' && !$long_options)) {
                $non_opts[] =  $arg; 
                // = array_merge($non_opts, array_slice($args, $i));
                //                break;
            } elseif (strlen($arg) > 1 && $arg{1} == '-') {
                $error = Console_Getopt::_parseLongOption(substr($arg, 2), $long_options, $opts, $args);
                //                if (PEAR::isError($error))
                //                    return $error;
            } elseif ($arg == '-') {
                // - is stdin
                $non_opts = array_merge($non_opts, array_slice($args, $i));
                break;
            } else {
                $error = Console_Getopt::_parseShortOption(substr($arg, 1), $short_options, $opts, $args);
                //                if (PEAR::isError($error))
                //                    return $error;
            }
        }

        return array($opts, $non_opts);
    }

    /**
     * @access private
     *
     */
    function _parseShortOption($arg, $short_options, &$opts, &$args)
    {
        for ($i = 0; $i < strlen($arg); $i++) {
            $opt = $arg{$i};
            $opt_arg = null;

            /* Try to find the short option in the specifier string. */
            if (($spec = strstr($short_options, $opt)) === false || $arg{$i} == ':')
            {
                return verify(false, "\nunrecognized option -$opt\n");
            }

            if (strlen($spec) > 1 && $spec{1} == ':') {
                if (strlen($spec) > 2 && $spec{2} == ':') {
                    if ($i + 1 < strlen($arg)) {
                        /* Option takes an optional argument. Use the remainder of
                           the arg string if there is anything left. */
                        //$opts[] = array($opt, substr($arg, $i + 1));
                        $opts[$opt] = substr($arg, $i + 1);
                        break;
                    }
                } else {
                    /* Option requires an argument. Use the remainder of the arg
                       string if there is anything left. */
                    if ($i + 1 < strlen($arg)) {
                        //            $opts[] = array($opt,  substr($arg, $i + 1));
                        $opts[$opt] =  substr($arg, $i + 1);
                        break;
                    } else if (list(, $opt_arg) = each($args)) {
                        /* Else use the next argument. */;
                        if (Console_Getopt::_isShortOpt($opt_arg) || Console_Getopt::_isLongOpt($opt_arg)) {
                            verify(false, "\noption requires an argument -$opt\n");
                        }
                    } else {
                        return verify(false, "\noption requires an argument -$opt\n");
                    }
                }
            }

            //            $opts[] = array($opt, $opt_arg);
            $opts[$opt] = $opt_arg;
        }
    }

    /**
     * @access private
     *
     */
    function _isShortOpt($arg)
    {
        return strlen($arg) == 2 && $arg[0] == '-' && preg_match('/[a-zA-Z]/', $arg[1]);
    }

    /**
     * @access private
     *
     */
    function _isLongOpt($arg)
    {
        return strlen($arg) > 2 && $arg[0] == '-' && $arg[1] == '-' &&
            preg_match('/[a-zA-Z]+$/', substr($arg, 2));
    }

    /**
     * @access private
     *
     */
    function _parseLongOption($arg, $long_options, &$opts, &$args)
    {
        @list($opt, $opt_arg) = explode('=', $arg, 2);
        $opt_len = strlen($opt);

        for ($i = 0; $i < count($long_options); $i++) {
            $long_opt  = $long_options[$i];
            $opt_start = substr($long_opt, 0, $opt_len);
            $long_opt_name = str_replace('=', '', $long_opt);

            /* Option doesn't match. Go on to the next one. */
            if ($long_opt_name != $opt) {
                continue;
            }

            $opt_rest  = substr($long_opt, $opt_len);

            /* Check that the options uniquely matches one of the allowed
               options. */
            if ($i + 1 < count($long_options)) {
                $next_option_rest = substr($long_options[$i + 1], $opt_len);
            } else {
                $next_option_rest = '';
            }
            if ($opt_rest != '' && $opt{0} != '=' &&
                $i + 1 < count($long_options) &&
                $opt == substr($long_options[$i+1], 0, $opt_len) &&
                $next_option_rest != '' &&
                $next_option_rest{0} != '=') {
                return verify(false, "\noption -$opt is ambiguous\n");
            }

            if (substr($long_opt, -1) == '=') {
                if (substr($long_opt, -2) != '==') {
                    /* Long option requires an argument.
                       Take the next argument if one wasn't specified. */;
                    if (!strlen($opt_arg) && !(list(, $opt_arg) = each($args))) {
                        return verify(false, "\noption -$opt requires an argument\n");
                    }
                    if (Console_Getopt::_isShortOpt($opt_arg) || Console_Getopt::_isLongOpt($opt_arg)) {
                        return verify(false, "\noption requires an argument -$opt\n");
                    }
                }
            } else if ($opt_arg) {
                return verify(false, "\noption -$opt doesn't allow an argument\n");
            }

            $opts[] = array('--' . $opt, $opt_arg);
            return;
        }

        return verify(false, "\nunrecognized option -$opt\n");
    }

    /**
    * Safely read the $argv PHP array across different PHP configurations.
    * Will take care on register_globals and register_argc_argv ini directives
    *
    * @access public
    * @return mixed the $argv PHP array or PEAR error if not registered
    */
    function readPHPArgv()
    {
        global $argv;
        if (!is_array($argv)) {
            if (!@is_array($_SERVER['argv'])) {
                if (!@is_array($GLOBALS['HTTP_SERVER_VARS']['argv'])) {
                    return verify(false, 
                                  "Console_Getopt: Could not read cmd args (register_argc_argv=Off?)");
                }
                return $GLOBALS['HTTP_SERVER_VARS']['argv'];
            }
            return $_SERVER['argv'];
        }
        return $argv;
    }

}





$YMDT_README = <<<EOT
This dir contains files to make a Yahoo! Mail Application.

Run ymdt to get an overview on how to exchange these files with a Yahoo!
Mail development server.

What's here to start with, for a minimal app?

config.xml:  app's config XML

auth.xml:  app's authentication XML

readme.txt: this file, ignored by Yahoo! tools

.appid: metadata for use by Yahoo! tools.  Do not modify.

views/:  subdirectory where you may add view html files

assets/:  subdirectory where you may add non-view assets
          it may contain other subdirectories

Portable Network Graphics files you could add at this directory's top-level:

icon[.<intl code>].png: a 16x16 pixel image for use as an icon in Yahoo! Mail

thumbnail[.<intl code>].png: a 64x64 pixel image for use in an app gallery

full[.<intl code>].png: a 300x250 pixel image for preview / help display purposes

Supported 'intl code' values are the same set of intls allowed in the schema for
the config XML.  The files without an intl code are the defaults.

EOT;


//Functions for logging onto Backyard and Yahoo!
class Login
{
    static function isWindows()
    {
        return preg_match('/^win/i', PHP_OS);
    }

    static function getHomeDir()
    {
        $home = getenv('HOME');
        return $home ? $home : getenv('HOMEPATH'); //windows
    }

    static function promptUserInput($prompt = 'username:', $echo = true)
    {
        printf($prompt);

        if($echo)
            return trim(fgets(STDIN));

        $isWindows = self::isWindows();
        if(!$isWindows){
            $stty = `stty -g`;
            system("stty -echo");
            $input = trim(fgets(STDIN));
            system("stty $stty");
            return $input;
        }
         
        //Windows doesn't let us turn off echoing on stdin Need access to win32
        //_getch() to implement this, unfortunately FFI is a PECL lib.  Alternatively,
        //there's a vb hack somewhere to make this throw up a dialog box w/ IE.
        return trim(fgets(STDIN));
    }

    static function promptCredentials($userPrompt, $passPrompt)
    {
        return array(self::promptUserInput($userPrompt), 
                     self::promptUserInput($passPrompt, false));
    }

    //on failure: returns false
    //on success: returns cookie string appropriate for curl_setopt(,CURLOPT_COOKIE,)
    static function authBackyard($bid, $password, $cookie_file_name, $use_guesthouse,
                                 $proxy = null, $proxyType = null, $verbose = false)
    {
       $url = "https://by.bouncer.login.yahoo.com/login/";
       if($use_guesthouse)
           $url = "https://gh.bouncer.login.yahoo.com/login/";

        $ch = curl_init();
        $timeout = 0;

        if($verbose)
            curl_setopt($ch, CURLOPT_VERBOSE, TRUE); 

        curl_setopt($ch, CURLOPT_POST, TRUE);
        curl_setopt($ch, CURLOPT_POSTFIELDS,
                    array('action' => 'login',
                          'id' => $bid,
                          'pass_word' => $password));

        curl_setopt($ch, CURLOPT_URL, $url);
        curl_setopt($ch, CURLOPT_HEADER, TRUE);
        if($cookie_file_name){
            curl_setopt($ch, CURLOPT_COOKIEJAR, $cookie_file_name);
            curl_setopt($ch, CURLOPT_COOKIEFILE, $cookie_file_name);
        }
        curl_setopt($ch, CURLOPT_RETURNTRANSFER, TRUE);
        curl_setopt($ch, CURLOPT_TIMEOUT, $timeout);

        if(self::isWindows()){
            curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, FALSE);
            curl_setopt($ch, CURLOPT_SSL_VERIFYHOST, FALSE);
        }
            
        if($proxy) {
            curl_setopt($ch, CURLOPT_PROXYTYPE, $proxyType);
            curl_setopt($ch, CURLOPT_PROXY, $proxy);
        }

        $result = curl_exec($ch);
        curl_close($ch);

        if($cookie_file_name)
            chmod($cookie_file_name, 0600);
        if($result === false || preg_match("/YBY=/", $result) != 1){
            return false;
        }
        
        preg_match_all('|Set-Cookie: (.*);|U', $result, $matches);
        return implode(';', $matches[1]);
        //        return true;
    }

    static function authYahoo($yid, $passwd, $cookie_file_name, $proxy, 
                              $proxyType, $verbose = false) 
    {
        $agent = 'Mozilla/5.0 (Macintosh; U; Intel Mac OS X 10.5; en-US;'.
                 'rv:1.9.0.5) Gecko/2008120121 Firefox/3.0.5';
        $ch = curl_init();
        curl_setopt(CURLOPT_TIMEOUT, 5);

        if($verbose)
            curl_setopt($ch, CURLOPT_VERBOSE, TRUE); 

        curl_setopt($ch, CURLOPT_USERAGENT, $agent);
        curl_setopt($ch, CURLOPT_HEADER, TRUE);
        if($cookie_file_name){
            curl_setopt($ch, CURLOPT_COOKIEJAR, $cookie_file_name);
            curl_setopt($ch, CURLOPT_COOKIEFILE, $cookie_file_name);
        }

        $postFields = "&login=$yid&passwd=$passwd";
        curl_setopt($ch, CURLOPT_POSTFIELDS, $postFields);
        curl_setopt($ch, CURLOPT_URL, 'https://login.yahoo.com');
        curl_setopt($ch, CURLOPT_RETURNTRANSFER, TRUE);
        curl_setopt($ch, CURLOPT_FOLLOWLOCATION, FALSE);

        if(self::isWindows()){
            curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, FALSE);
            curl_setopt($ch, CURLOPT_SSL_VERIFYHOST, FALSE);
        }

        if($proxy) {
            curl_setopt($ch, CURLOPT_PROXYTYPE, $proxyType);
            curl_setopt($ch, CURLOPT_PROXY, $proxy);
        }

        //        echo "Curl execing . . \n\n";
        $result = curl_exec($ch);
        //        echo "Login result: $result\n\n";
        $http_code = curl_getinfo($ch, CURLINFO_HTTP_CODE);
        curl_close($ch);

        preg_match_all('|Set-Cookie: (.*);|U', $result, $matches);

        if(self::checkCookies($matches[1])){
            return implode(';', $matches[1]);
        }
        return null;
    }

    static function checkCookies($cookie_lines)
    {
        $cookies = array();
        foreach($cookie_lines as $line) {
            $ndx = strpos($line, '=');
            if($ndx === false)
                continue;

            $key = substr($line, 0, $ndx);
            $val = substr($line, $ndx+1);;
            $cookies[$key] = $val;
        }

        if(!count($cookies)){
            return null;
        }

        //OK if this isn't perfect, server will do a hard check.
        if(!array_key_exists('Y', $cookies) ||
           !array_key_exists('T', $cookies))
            return false;
        if($cookies['T'] == 'z=0')
            return false;

        return true;
    }

    static function extractBID_FromCookie($cookie_file_name)
    {
        if(!file_exists($cookie_file_name))
            return null;

        static $regex = '/YBY\sid%3D[0-9]+%26userid%3D([^%]+)%26/';
        $matches = array();
        $contents = file_get_contents($cookie_file_name);
        $count = preg_match($regex, $contents, $matches);
        if($count != 1){
            return null;
        }
        return $matches[1];
    }
}



//Wraps calls to the development server.
class WebServiceClient
{
    //We'll throw an exception with this string as the message if we ever try to login and
    //and auth succeeds but there is no developer with that ID.
    const USER_UNREGISTERED_EXCEPTION_MSG = 'No such user registered';

    //proxyHTTP takes precedence over proxySOCKS
    function __construct($hostname, $cookieFname, $lamessl, $uname, $passwd, 
                         $proxyType = null, $proxy = null, $verbose = false,
                         $authType = 'Yahoo!')
    {
        $this->hostname = $hostname;
        echo "Developer server: " . $this->hostname . "\n";
        $this->cookieFname = $cookieFname;
        $this->lamessl = $lamessl;
        $this->uname = $uname;
        $this->passwd = $passwd;
        $this->wssid = null;
        $this->proxy = $proxy;
        $this->verbose = $verbose;
        $this->proxyType = $proxyType;
        $this->authType = $authType;
    }
	
	static function extractServerName(&$result, &$header_size)
	{
		$header = substr($result, 0, $header_size);
		
		$webServer = "(unknown)";
		$pos = TRUE;  
		$pos = strpos($header, "x-debug-hostname: ");

		if(FALSE == $pos) 
			return $webServer;
		
		$header = substr($header, $pos + strlen("x-debug-hostname: "));
		$pos = strpos($header, ".com");
		$webServer = substr($header, 0, $pos + 4);
		
		return $webServer;
	} 
	
	static function logServerName(&$hostName, &$op)
	{
		$msg = 'Web service call ' . $op . ' served by: ' . $hostName . "\n"; 
		error_log($msg);
	}
	
    function call($op, &$msg, $fields = array(), $format = 'json',
                  $checkStatus = true, $needLogin = true, $urlXtra = null)
    {
        if(!$this->wssid && $needLogin)
            $this->login();

        $url = 'https://' . $this->hostname;
        if(strpos($op, 'admin.') !== false)
            $url = 'http://' . $this->hostname . ':9999';

        $url .= '/om/api/1.0/openmail.' . $op;
        
        if($this->authType == 'Yahoo!')
            $url .= '?crumb=';
        else
            $url .= '?bycrumb=';

        if($this->wssid){
            $url .= $this->wssid;
        }

        if($urlXtra)
            $url .= $urlXtra;

        $ch = curl_init();
        $timeout = 0;

        if($this->verbose)
            curl_setopt($ch, CURLOPT_VERBOSE, TRUE); 

        curl_setopt($ch, CURLOPT_POST, TRUE);
        curl_setopt($ch, CURLOPT_POSTFIELDS, $fields);
        curl_setopt($ch, CURLOPT_URL, $url);
        curl_setopt($ch, CURLOPT_HEADER, TRUE);
        curl_setopt($ch, CURLOPT_RETURNTRANSFER, TRUE);
        curl_setopt($ch, CURLOPT_TIMEOUT, $timeout);
        if($this->cookieFname){
            curl_setopt($ch, CURLOPT_COOKIEFILE, $this->cookieFname);
            //            echo "sending from file cookies\n";
        }
        else{
            curl_setopt($ch, CURLOPT_COOKIE, $this->cookies);
            //   echo "sending from raw cookies\n";
        }
        curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, FALSE);
        if($this->lamessl)
            curl_setopt($ch, CURLOPT_SSL_VERIFYHOST, FALSE);

        if($this->proxy) {
            curl_setopt($ch, CURLOPT_PROXYTYPE, $this->proxyType);
            curl_setopt($ch, CURLOPT_PROXY, $this->proxy);
        }

        $result = curl_exec($ch);
        $errno = curl_errno($ch);
        if($errno){
            $msg = curl_error($ch) . " [curl errno $errno]";
            if($errno == 51)
                $msg .= "\n\nUse -k to skip SSL host verification.";
            verify(false, $msg);
        }
        
        $http_code = curl_getinfo($ch, CURLINFO_HTTP_CODE);
        $header_size = curl_getinfo($ch, CURLINFO_HEADER_SIZE);

        curl_close($ch);
        if(file_exists($this->cookieFname))
            chmod($this->cookieFname, 0600);
		
		$webServer = self::extractServerName($result, $header_size);
		
		self::logServerName($webServer, $op);
		
		$content = substr($result, $header_size);

        $rval = null;
        if($format){
            if($format == 'json')
                $rval = json_decode($content);
            elseif($format == 'xml')
                $rval = simplexml_load_string(trim($content));
            if(!get_class($rval) && !is_array($rval))
                $rval = null;
        }

        if($http_code != '200'){
            $msg = "$op invoke failed (HTTP $http_code).\n";
            if(!$rval && $format == 'xml'){
                $rval = json_decode($content); //error might actually be json
            }
            if($rval && property_exists($rval, 'message')){
                $txt = wordwrap($rval->message, 80) . "\n";
                $msg .= "\nServer says: $txt";
            }
            $str=curl_error($ch);
            if($str)
                $msg .= "\n Curl says: $str";

            $msg .= "\nWebserver: $webServer"; 
            
            verify(false, $msg);
        }

        if(!$format)
            return $content;

        verify($rval !== null,
               "Unexpected webservice result from $op: \n$format:\n\t[$content]");

        //Would be nice if ws results were a little more standardized, a la JSON-RPC.
        //But, they're not. . .
        $msg = @property_exists($rval, 'message') ? $rval->message : '';
        if($checkStatus && $rval->status != 200){
            $msg = $msg . " (status: {$rval->status})";
	
			if($webServer != "")
				$msg .= "\nWebserver: $webServer"; 
            
            verify(false, $msg);
        }

        return $rval;
    }

    //Throws exception if wssid couldn't be retrieved
    //Returns false iff the Yahoo! ID isn't set up as a developer.
    function getWSSID()
    {
        $wsapi = 'dev.file.handshake';
        if($this->authType == 'Backyard')
            $wsapi = 'services.getBackyardCrumb';

        //This call, unlike all the others, returns in XML (since JSON is
        //security no-no for wssid.)
        try{
            $result = $this->call($wsapi, $msg, array('version' => CLI_Version), 
                                  'xml', false, false);
        }
        catch (Exception $e){
            if(strstr($e->getMessage(), "(HTTP 302)") !== false){
                verify(false, 
                       "Are you connecting to a server that supports ymdt 1.0+?\n".
                       "If not, try downloading that server's version of ymdt:\n".
                       "\thttp://{$this->hostname}/openmail/download_ymdt.php\n\n");
            }
            throw $e;
        }

        if($result && !property_exists($result, 'wssid')){
            verify(false, $result->message);
        }

        $this->wssid = $result->wssid;
        $this->admin = $result->admin;
        if(property_exists($result, 'version')){
            $this->serverCLI_Version = $result->version;
            if(CLI_Version < $result->version){
                $latest = $result->version;
                echo "***You are running an outdated version of ymdt ".
                    "(latest is $latest, you have " . CLI_Version . ".).\n".
                    "***Please run: ymdt upgrade\n\n";
            }
        }

        if($result && $result->status == 544/*ERROR_OTHER_UNREGISTERED_USER*/)
            return false;
        return true;
    }

    function resetCookies()
    {
        verify(!file_exists($this->cookieFname) ||
               unlink($this->cookieFname),
               "Fought {$this->cookieFname} and lost");        
    }

    function login($requireDevAccount = true)
    {
        $uname = $this->uname;
        $passwd = $this->passwd;

        //Blow away cookie file if user specified.
        if($uname)
            $this->resetCookies();

        //If we can't get a WSSID, try logging in to refresh cookie, then try
        //getting crumb again.
        try {
            $this->getWSSID();
            if($this->wssid){
                return;
            }
        } catch (Exception $e) {}

        if(!$uname){
            $prompt = "{$this->authType} ID: ";
            list($uname, $passwd) = Login::promptCredentials($prompt,
                                                             'Password: ');
        }
        elseif(!$passwd){
            $passwd = Login::promptUserInput('Password:', false);
        }
        $this->resetCookies();
        $this->cookies = $this->authenticate($uname, $passwd);
        verify($this->cookies, "\nUnable to login with your {$this->authType} ".
                               "ID and password.");

        if($this->cookieFname){
            echo "".
            "\nAn authentication token has been stored in {$this->cookieFname}\n".
            "\nUntil its expiration, ymdt will use it to login.\n".
            "To disable this behavior, use the -d option.\n\n";
            $this->uname = $uname;
        }

        $isUserADev = false;
        try {
            $isUserADev = $this->getWSSID();
        }
        catch (Exception $e){
            echo $e->getMessage();
            exit(-1);
        }
        
        if($requireDevAccount && !$isUserADev){
            $this->resetCookies();
            verify(false, "Your Yahoo! ID is not activated for development.\n".
                   "Run 'ymdt signup' to get started.\n\n".
                   "Previously registered with a Guesthouse account?\n".
                   "Run 'ymdt migrate' to convert your account to your Yahoo! ID.\n");
        }
    }

    function useGuesthouse()
    {
        return  strpos($this->hostname, 'corp.yahoo.com') === false;
    }

    function migrate()
    {
        verify( !file_exists($this->cookieFname) || unlink($this->cookieFname), 
                "Couldn't delete " . $this->cookieFname . '.');

        $use_guesthouse = $this->useGuesthouse();
        $bouncer = $use_guesthouse ? 'Guesthouse' : 'Backyard';

        $prompt = "Previously-registered $bouncer ID: ";
        list($bid, $bpasswd) = Login::promptCredentials($prompt, 'Password: ');
        $cookies = Login::authBackyard($bid, $bpasswd, $this->cookieFname, 
                                       $use_guesthouse, $this->proxy, $this->proxyType);
        verify($cookies, "$bouncer login failed");
        $this->authType = 'Backyard';
        $this->cookies = $cookies;
        $this->getWSSID();
        verify($this->wssid, "$bouncer wssid failure");
        $bycrumb = $this->wssid;
        $this->wssid = null;
        $this->authType = 'Yahoo!';

        echo "\n\n";
        $prompt = 'Yahoo! ID to migrate to: ';
        list($yid, $ypasswd) = Login::promptCredentials($prompt, 'Password: ');
        $this->cookies = Login::authYahoo($yid, $ypasswd, $this->cookieFname, $this->proxy,
                                          $this->proxyType, $this->verbose);


        verify($this->cookies, 'Yahoo! login failed.');

        $this->cookies = $cookies . ';' . $this->cookies;

        $result = $this->call('dev.file.handshake', $msg, 
                              array('version' => CLI_Version), 'xml', false,
                              false);
        verify($result, "Server handshake error.");
        verify(property_exists($result, 'wssid'), "Server didn't give WSSID.");
        $this->wssid = $result->wssid;

        $msg = null;

        $result = $this->call('dev.developer.migrate', $msg, array(), 'json',
                              true, true, "&bycrumb=$bycrumb");
        verify($result, "No webservice result.");
        echo "\n" . $result->message . "\n";
    }

    function appList($showSampleApps = false)
    {
        $msg = null;
        $fields = array('ignorePublicationStatus' => 'true',
                        'samples' => ($showSampleApps ? 'true' : 'false'));
        verify(($result = $this->call('dev.app.list', $msg, $fields, 'json',
                                      false)) !== null,
               "No webservice result.");
        return $result;
    }

    function ls($appid, $subpath = null)
    {
        $fields = array('app' => $appid);
        if($subpath){
            $fields['path'] = $subpath;
        }

        $result = $this->call('dev.file.ls', $msg,  $fields);
        return get_object_vars($result->data);
    }

    //upgrade helper, not really a ws call
    function fetchLatestScript()
    {
        $ch = curl_init();
        $timeout = 0;
        $url = 'https://' . $this->hostname . '/openmail/assets/ymdt';
        if($this->verbose)
            curl_setopt($ch, CURLOPT_VERBOSE, TRUE);

        curl_setopt($ch, CURLOPT_URL, $url);
        curl_setopt($ch, CURLOPT_HEADER, TRUE);
        curl_setopt($ch, CURLOPT_RETURNTRANSFER, TRUE);
        curl_setopt($ch, CURLOPT_TIMEOUT, $timeout);
        curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, FALSE);
        if($this->lamessl)
            curl_setopt($ch, CURLOPT_SSL_VERIFYHOST, FALSE);
        if($this->proxy) {
            curl_setopt($ch, CURLOPT_PROXYTYPE, $this->proxyType);
            curl_setopt($ch, CURLOPT_PROXY, $this->proxy);
        }

        $result = curl_exec($ch);
        $http_code = curl_getinfo($ch, CURLINFO_HTTP_CODE);
        $header_size = curl_getinfo($ch, CURLINFO_HEADER_SIZE);
        curl_close($ch);
        $content = substr($result, $header_size);
        verify($http_code == '200' && !empty($content),
               "Upgrade fetch failed (HTTP $http_code).");
        return $content;
    }

    function isAdmin() { return $this->admin; }

    function authenticate($uname, $passwd)
    {
        if($this->authType == 'Yahoo!')
            return Login::authYahoo($uname, $passwd, $this->cookieFname, 
                                    $this->proxy, $this->proxyType,
                                    $this->verbose);

        verify($this->authType == 'Backyard');
        $use_guesthouse = $this->useGuesthouse();
        return Login::authBackyard($uname, $passwd, $this->cookieFname, 
                                   $use_guesthouse, $this->proxy, 
                                   $this->proxyType, $this->verbose);

    }

};



define('CLI_Version', '1.14');



/**
    Usage:

    ymdt <command> [flags] [command arguments]

    Type 'ymdt help <command>' for help on a specific command.

    Available commands:
        apps     lists all of your apps
        create   creates a new app
        destroy  delete the entire app
        del      deletes one of an app's files
        dev      develop-o-matic mode
        get      get latest of an app's file(s) from dev server
        help     get help on a specific command
        ls       list all of an app's file(s) and their URLs
        put      upload apps file(s) to dev server
        signup   set up your account for doing development
        tester   list, invite, or delete testers
*/
class YMDT extends CLI
{
    const OPTS___CONSTRUCT = CLI::OPTS___CONSTRUCT;
    public function __construct($hostname = null, $lamessl = false, 
                                $username = null, $password = null, $proxyOpts = null,
                                $nocookies = null, $verbose = false)
    {
        parent::__construct($hostname, $lamessl, $username, $password, 
                            $proxyOpts, $nocookies, $verbose, '.ymdtcookie');
    }

    const OPTS_APPS = 'S';
    /**
        usage:  apps

        Lists all of the logged-on user's apps.
    
        Each app is reported as a line beginning with the appid, followed by a
        tab and then the app name.

        Options: 
            -S
            Instead of showing apps created by the logged-on user, show sample
            apps.
    */
    public function apps($showSampleApps = false)
    {
        $result = $this->ws->appList($showSampleApps);

        if($showSampleApps && empty($result)){
            echo "Sample apps temporarily unavailable.\n";
            return;
        }

        if(empty($result)){
            echo "You have not created any apps yet.  ".
                "ymdt help create for more info.\n";
            return;
        }

        printf("\n%-16s %-16s %.100s", 'private appid', 'public appid', 'name');
        printf("\n%-16s %-16s %.100s", '--------------', '--------------', 
               '---------------------------------------------');
        foreach ($result as $r) {
            if(!$r->published_to){
                $priv_id = '<unknown>';
                $pub_id = $r->app;
            }
            else{
                $priv_id = $r->app;
                $pub_id = $r->published_to;
            }
            printf("\n%-16s %-16s %.100s", $priv_id, $pub_id,
                   $r->name);
        }
        echo "\n";
    }

    const OPTS_CREATE = 'S:';
    /**
       usage: create <path>
       
       Create an app on the development server, with a local working copy kept
       in <path>.

       If <path> doesn't already contain an app, a minimal app will be created.

       If <path> already contains an app,  a new app will be created based on
       the app files in <path>, and <path> will be converted to a valid working
       directory for the newly-created app.

       In either case, the app name will be set to '<path>', but you can modify it
       to be different from '<path>' by editing the app's config.xml.

       For a description of the files comprising an app, see <path>/readme.txt.

       Options:
           -S <sample app name>
           Instead of creating a minimal app, create an app based on a sample.
           For a list of available samples:  ymdt apps -S
           
       Examples:
          create a new app in directory ~/apps/llama:
               ymdt create ~/apps/llama

          create a new app in directory hello based on the 'Hello World' sample
               ymdt create hello -S 'Hello World'

    */
    public function create($appdir, $sample = null)
    {
        verify(file_exists($appdir) || FileSys::mkdir($appdir),
               "Couldn't create dir $appdir");

        if($sample){ //sync the directory to the source for the named sample
            echo "Getting sample '$sample' into $appdir:\n";
            $this->get($appdir, null, true, true, null, $sample);
        }
        
        $appidFname = $appdir.'/'.FileSys::APPID_FNAME;
        $confFname = $appdir.'/'. 'config.xml';

        //If it's not a virgin app, we have a local working copy already
        //(i.e. that we've unzipped from someone else), just nothing on the
        //server yet.
        $isVirginApp = !file_exists($confFname);
        
        // Get the app name from conf file.
        $appName = basename($appdir); // By default create App with base dir name
        
        if(!$isVirginApp){
            $conf = file_get_contents($confFname);
            $xml = simplexml_load_string($conf);
            if($xml && property_exists($xml, 'name')){
                $appName = $xml->name;
            }else{
                echo "WARNING: Failed to extract App Name from config.xml. App will be created with base dir name. \n";
            }
        }
        
        $fields = array('name' => $appName);

        verify(($result = $this->ws->call('dev.app.create', $msg, $fields)),
               "No webservice result.");
        
        verify(file_put_contents($appidFname, $result->id) !== false,
               "Couldn't write $appidFname for {$result->id}");

        echo($result->message . "\n");

        if(!$isVirginApp)
            return self::put($appdir);

        FileSys::layout(FileSys::realpath($appdir));
        return self::get($appdir);
    }
        
    /**
       usage: del <path> 

       Delete one of an app's files.  Only delete's the analogous file on the server, 
       leaving the local copy intact.  

       <path> must be to a single file in an app's local working directory.

       Examples:
          delete asset 'lark.jpg' for app in directory ./birds:
               ymdt del ./birds/assets/lark.jpg
    */
    function del($path)
    {
        list($appid, $basepath, $subpath) = FileSys::parsePath($path);
        verify($subpath, 'del must reference file in working app dir');

        if(file_exists($path))
            verify(!is_dir($path), 'del requires a path to a single file');

        $fields = array('app' => $appid);
        $fields['path'] = $subpath;
            
        $json = $this->ws->call('dev.file.del', $msg,  $fields);
        echo "\tdeleted $path from server\n";
        return;
    }

    /**
       usage: dev <path>

       Enter dev-o-matic mode.  <path> must be to the root of an app's local
       working directory.  Will do a get of app, then continuously watch for
       local changes and update the server.
    */
    function dev($path)
    {
        //todo: offer choice of starting with sync from server to local dir or
        //      vice versa.  Make sure this is an app dir, or you have an appid,
        //      etc.
        self::get($path);
        echo "\nMonitoring $path for changes.  Hit Ctrl-C to exit\n\n";


        $prevFiles = FileSys::expandPaths(array($path));
        $prevFiles = FileSys::filterMetaFiles($prevFiles, $path, 
                                              !$this->ws->isAdmin());
        $tmLastMod = max(array_map(array('FileSys', 'modTime'), $prevFiles));

        while(true){
            $files = FileSys::expandPaths(array($path));
            $files = FileSys::filterMetaFiles($files, $path, 
                                              !$this->ws->isAdmin());
            $deletes = array_diff($prevFiles, $files);
            $updates = array();
            $tmMaxMod = $tmLastMod;
            foreach($files as $f){
                $tmMod = stat($f);  $tmMod = $tmMod['mtime'];
                if($tmMod <= $tmLastMod)
                    continue;
                $updates[] = $f;
                $tmMaxMod = max($tmMaxMod, $tmMod);
            }
            if(!empty($updates) || !empty($deletes)){
                echo "\nNoticed some changes in $path, syncing. . .\n";
                array_walk($updates, array($this, 'putOne'));
                array_walk($deletes, array($this, 'del'));
                echo "Sync done.\n";
            }
            $prevFiles = $files;
            $tmLastMod = $tmMaxMod;
            usleep(1000 * 100);
        }
    }

    const OPTS_DESTROY = 'a:';
    /**
       usage: destroy [<path>]

       Destroy an application.  Must specify the path or the -a flag.

       Options:
           -a<appid>
           <appid> is the application's private appid.
    */
    function destroy($appdir = null, $appid = null)
    {
        verify($appdir || $appid, "Must specify either appdir or -a.");
        if(!$appid){
            list($appid, $basepath, $subpath) = FileSys::parsePath($appdir);            
        }

        $fields = array('app' => $appid);
        $call = 'dev.app.delete';
        verify(($result = $this->ws->call($call, $msg, $fields)),
               "No webservice result.");
        
        echo($result->message . "\n");
    }

    const OPTS_GET = 'a:syn:S:';
    /**
       usage: get <path>

       Get latest of an app's file(s) from dev server.  Normally, <path> is to the root
       or some subpath of the app's local working copy.  Wildcards (?*) allowed below
       app root, but only if <path> is quoted.

       Options:
           -a<appid>
           Get an app that exists on the server, but for which you don't yet have
           a working copy.  In this case, <path> must be to an empty directory.

           -s
           Sync:  Do the get, but also delete any local files below <path> that
           aren't present on the server.

           -y
           Autoyes:  don't prompt user to confirm local deletes, use with care!

           -n<app name>
           Get an app with that name that was created by the logged-on developer.

           -S<sample name>
           Get the named sample app from the server.

        Examples:
            get latest of all files for app 045fa65e3, using directory duck as the
            local working directory:
                ymdt get duck -a045fa65e3 

            get latest of all files for app in directory ./scrooge:
                ymdt get ./scrooge

            get latest of all assets for app in directory ./mcduck:
                ymdt get ./mcduck/assets

            get latest of config for app in directory ./ham:
                ymdt get ./ham/config.xml

            get latest of .js files in ./ham/assets
                ymdt get './ham/assets/*.js'

            get the 'Hello World' sample app source
                ymdt get hello -S 'Hello World'
    */
    function get($path, $appid = null, $sync = false, $autoYes = false, 
                 $name = null, $sample = null)
    {
        if($sample)
            $appid =$this->changeWorkingAppidFromName($path, $sample, true);
        else if($name)
            $appid =$this->changeWorkingAppidFromName($path, $name);

        if($appid){
            list($subpath, $basepath) = array(null, $path);
            $fname = $basepath.'/'.FileSys::APPID_FNAME;
            FileSys::mkdir($basepath);
            verify(file_put_contents($fname, $appid), "Couldn't write $fname.");
            FileSys::layout($basepath);
        }
        else{
            list($appid, $basepath, $subpath) = FileSys::parsePath($path);
        }
        $fetchedPaths = self::lsAndGet($appid, $subpath, $basepath);
        if(!$sync)
            return;

        $fetchedPaths = array_map(array('FileSys', 'realpath'), $fetchedPaths);
        $localPaths = FileSys::expandPaths(array($path));
        //        echo 'localPaths: ' . print_r($localPaths, true) . "\n";
        $localPaths = FileSys::filterMetaFiles($localPaths, 
                                               FileSys::realpath($basepath),
                                               !$this->ws->isAdmin());
        //        echo 'filtered: ' . print_r($localPaths, true) . "\n";
        //echo 'fetched: ' . print_r($fetchedPaths, true) . "\n";

        $deletes = array_diff($localPaths, $fetchedPaths);
        if(!$autoYes &&
           !self::confirmDeletes($deletes, 
                                 "\nThe following files aren't present on the server:\n",
                                 "\nWould you like to delete the local copies? "))
            return;

        foreach($deletes as $d){
            verify(unlink($d) , "Couldn't delete $d");
            echo "\tdeleted $d\n";
        }
    }

    /**
       usage: ls <path>

       List server-side files and their URLs.

       <path> must minimally be an app's working directory, in which case all of the
       files comprising the app will be listed.  <path> may also specify a particular
       subdir or file inside the app's working directory.  Wildcards (*?) allowed below
       app's working directory root.

       Options:
       -z
       Show the raw server side URL.

       Examples:
          list all assets for app in directory ~/apps/pigeon:
              ymdt ls ~/apps/pigeon/assets

          list all .jpg assets for app in directory ~/apps/zebra:
              ymdt ls '~/apps/zebra/assets/*.jpg'
              # note quotes to avoid shell expansion

          list the raw .jpg assets for app in directory ~/apps/zebra:
              ymdt ls -z '~/apps/zebra/assets/*.jpg'
              # note quotes to avoid shell expansion
    */

    const OPTS_LS = 'z';
    function ls($path, $raw = false)
    {
        list($appid, $basepath, $subpath) = FileSys::parsePath($path);
        $results = $this->ws->ls($appid, $subpath, $raw);

        foreach($results as $fname => $url) {
            if(! $raw)
                $url = preg_replace("@/om/assets/.+?_\d+/@",
                                    "/yahoo/mail/assets/", $url);
            echo "\t" . $fname . "\t" .  $url . "\n";
        }
    }

    const OPTS_PUT = 'a:nsy';
    /**
       usage: put <path>

       Upload files from local app working copy to the server.  <path> is the root or
       some subpath of the app's local working copy.  Wildcards (?*) allowed below app
       root, but only if <path> is quoted.

       Options:

          -a<appid>
          Explicitly specify the appid of the destination app on the server.
          Normally the .appid in the root directory of the app's local working
          copy determines what app is modified on the server.  Since you may
          only modify the private (in-development) version of your app, <appid>
          must be a private appid.  Changes .appid in your app's working dir
          as well.

          -n
          Use the application name from the app's conf.xml to lookup the app's
          private appid on the server and modify the .appid file in your local
          working copy.  For situations where you created the local working copy
          by doing a get -a with a public appid or if you've done a get -h from
          a different server.  Revises the .appid so that future puts will apply
          to the private app on the correct server.

          -s
          Sync:  Do the put, but also delete any files on the server that aren't
          present in the local working copy.

          -y
          Autoyes:  don't prompt user to confirm server deletes, use with care!

       Examples:
          upload all files for app in directory ./mcduck:
               ymdt put ./mcduck

          upload all assets for app in directory ./phish:
               ymdt put ./phish/assets

          upload latest of .js files in ./ham/assets
               ymdt put './ham/assets/*.js'
    */
    function put($pattern, $appidOverride = null, $appidFromName = false, 
                 $sync = false, $autoYes = false)
    {
        $noClimb = $appidFromName || $appidOverride;
        list($appid, $basepath, $subpath) = FileSys::parsePath($pattern, $noClimb);

        if($appidOverride){
            $appid = $this->changeWorkingAppid($basepath, $appidOverride);
        }

        if($appidFromName){
            verify(!$appidOverride, "put can't accept both -n and -a");
            $appid = $this->changeWorkingAppidFromName($basepath, 
                                                       FileSys::nameFromConfFile($basepath));
        }

        $paths = FileSys::expandPaths(glob($pattern, GLOB_MARK));
        $paths = FileSys::filterMetaFiles($paths, $basepath, 
                                          !$this->ws->isAdmin());
        array_walk($paths, array($this, 'putOne'));

        if(count($paths) > 1)
            echo "Done all puts for $pattern.\n";

        if(!$sync)
            return;
            
        echo "\tappid now $appid\n";
        $remote_paths = $this->ws->ls($appid, $subpath);
        $remote_paths = array_keys($remote_paths);
        
        //Need relative (to app root) paths
        $root = FileSys::realpath($basepath);
        $newpaths = array();
        foreach($paths as $p){
            $newpaths[] = substr($p, strlen($root)+1);
        }
        $paths = $newpaths;

        $deletes = array();

        //echo 'remote paths: ' . print_r($remote_paths, true) . "\n\n";
        //echo 'paths: ' . print_r($paths, true) . "\n\n";

        foreach($remote_paths as $p){
            if(in_array($p, $paths) || is_dir($p))
                continue;
            $deletes[] = $p;
        }

        if(!$autoYes && 
           !self::confirmDeletes($deletes, 
                                 "\nThe following files aren't present locally:\n",
                                 "\nWould you like to delete them from the server? "))
            return;

        foreach($deletes as $path){
            $fields = array('app' => $appid);
            $fields['path'] = $path;
            $json = $this->ws->call('dev.file.del', $msg,  $fields);
            echo "\tdeleted $path from server\n";
        }
    }

    /**
       usage: tester <ls|invite|del> [tester email address]

       tester ls will display your tester list.

       tester invite <tester email address> will invite someone to be a tester.

       tester del <tester email address> will delete an existing tester.
    */
    function tester($subcmd = null, $emailOrYid = null)
    {
        $legalSubs = array('ls', 'del', 'invite');
        verify($subcmd && in_array($subcmd, $legalSubs), 
               "tester command requires a subcommand, one of: " .
               implode(', ', $legalSubs) . ".");

        if($subcmd == 'ls')
            return $this->testerLs();

        $msg = '';
        if($subcmd == 'del'){

			verify($emailOrYid, "tester del requires the tester's email address.");
  
			$fields = array('email' => $emailOrYid); 
            $result = $this->ws->call('dev.yid.remove', $msg,  $fields);
            echo "tester's $emailOrYid deleted.\n\n";
            return;
        }

        verify($emailOrYid, "tester invite requires the tester's Yahoo email address.");
        $fields = array('email' => $emailOrYid);
        
        
        error_log("Inviting $emailOrYid");
        
        $result = $this->ws->call('dev.yid.add', $msg,  $fields);
        
        echo "Tester $emailOrYid invited.\n\n";
    }

    function testerLs()
    {
        $fields = array();
        $arr = $this->ws->call('dev.yid.list', $fields, $msg, 'json', false);
        verify(is_array($arr), "Unexpected ws result for dev.yid.list: "
               . print_r($arr, true));
        printf("%-32s %-16s\n", 'Yahoo! Email', "Pending?");
        printf("-----------------------------------------\n");
        foreach($arr as $tester){
            printf("%-32s %-16s\n", $tester->email,
                   $tester->pending ? 'yes' : '');
        }
    }

    function confirmDeletes($deletes, $list_header, $question)
    {
        if(!empty($deletes)){
            echo $list_header;
            foreach($deletes as $d){
                echo "\t$d\n";
            }
            $response = Login::promptUserInput($question);
            if(strtolower($response[0]) === 'n'){
                return false;
            }
        }
        return true;
    }

    function lsAndGet($appid, $src_subpath, $dest_basepath)
    {
        //Do an ls first in case they're using a dir or glob for path.
        $results = $this->ws->ls($appid, $src_subpath);
        $count = 0;
        //Get each file returned by ls
        $local_file_paths = array();
        foreach($results as $fname => $url){
            $fields = array('app' => $appid, 
                            'name' => $fname);
            $file_path = $dest_basepath . '/' . $fname;
            echo "\tdownloading $file_path. . .\n";
            $result = $this->ws->call('dev.file.get', $msg, $fields, null);

            FileSys::mkdir(dirname($file_path));

            verify(file_put_contents($file_path, $result) !== false, 
                   "Couldn't write $file_path");
            $local_file_paths[] = $file_path;
            $count ++;
        }
        if($count > 1)
            echo "Done all gets for $dest_basepath.\n";
        return $local_file_paths;
    }

    private function changeWorkingAppidFromName($appdir, $name, $isSample = false)
    {
        $list = $this->ws->appList($isSample);

        $appid = null;
        foreach($list as $app){
            if($name != $app->name)
                continue;
            verify(!$appid,
                   "More than one app named '$name'.");
            $appid = $app->app;
        }
        if(!$appid){
            verify($isSample, "No app named '$name' for logged-on developer.");
            verify(false,  "No sample named '$name'.\n  ".
                   "You can list samples with: ymdt apps -S\n");
        }

        return $this->changeWorkingAppid($appdir, $appid);
    }
    
    private function changeWorkingAppid($appdir, $appid)
    {
        FileSys::mkdir($appdir);
        verify(file_put_contents($appdir . '/' . FileSys::APPID_FNAME, $appid)
               !== FALSE);
        echo "\tchanged appid to $appid. \n";
        return $appid;
    }

    function putOne($path)
    {
        echo "\tuploading $path. . .\n";

        list($appid, $basepath, $subpath) = FileSys::parsePath($path);

        $contents = file_get_contents($path);
        verify($contents !== false, "Couldn't read contents of $path.");

        $fields = array('app' => $appid, 
                        'name' => $subpath, 
                        'file' => '@' . $path);

        $result = $this->ws->call('dev.file.put', $msg, $fields);

        return;
    }

    function migrate()
    {
        $this->ws->migrate();
    }

    /**
       usage:  signup

       Signup for a developer account.
    */
    function signup()
    {
        $msg = null;
        $fields = array();
        $this->ws->login(false /*don't require dev account*/);
        $this->ws->call('dev.developer.signup', $msg, $fields, 'json', true, 
                        false /*bypass autologin*/);
        echo "$msg\n";
    }

    const OPTS_UPGRADE = 'z';
    /**
       usage: upgrade

       Download the latest version of ymdt and replace the running script with it.

       Options:
           -z
           Allow downgrade.  Normally, if your version of ymdt is more recent 
           than what's on the developement server, ymdt upgrade does nothing.  
    */
    function upgrade($allowDowngrade = false)
    {
        verify(!strpos(__FILE__, '.php'),
               "Can't upgrade source file, only built version.");

        $this->ws->login();
        $svrVersion = $this->ws->serverCLI_Version;
        verify($allowDowngrade || $svrVersion >= CLI_Version,
               "Server version ($svrVersion) older than current version (" .
               CLI_Version . ').  Use ymdt upgrade -z to allow downgrade.');

        $newYmdt = $this->ws->fetchLatestScript();

        $archive = __FILE__ . '.old';
        verify(copy(__FILE__, $archive),
               "Upgrade failed, couldn't archive current version to $archive.");
        verify(file_put_contents(__FILE__, $newYmdt) !== false, 
               "Upgrade failed, couldn't write " . __FILE__);
        echo "Done upgrade, previous version archived to $archive.\n"; 
        return 0;
    }

    static function isLegalCmd($cmd)
    {
        static $cmds = array('apps', 'create', 'ls', 'get', 'help', 
                             'put', 'del', 'dev', 'upgrade', 
                             'destroy', 'tester', 'migrate', 'signup');
        return in_array($cmd, $cmds);
    }
}

function main()
{
    echo "Yahoo! Mail Development Tool Version " . CLI_Version . "\n";

    $dispatcher = new CmdLineDispatcher('YMDT');
    $dispatcher->dispatch();
}

main();

?>
